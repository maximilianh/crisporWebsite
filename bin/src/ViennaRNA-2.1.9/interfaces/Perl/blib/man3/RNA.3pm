.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RNA 3pm"
.TH RNA 3pm "2015-02-05" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
RNA \- interface to the Vienna RNA library (libRNA.a)
Version 0.3
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\&  use RNA;
\&  $seq = "CGCAGGGAUACCCGCG";
\&  ($struct, $mfe) = RNA::fold($seq);  #predict mfe structure of $seq
\&  RNA::PS_rna_plot($seq, $struct, "rna.ps");  # write PS plot to rna.ps
\&  $F = RNA::pf_fold($seq);   # compute partition function and pair pobabilities
\&  RNA::PS_dot_plot($seq, "dot.ps");          # write dot plot to dot.ps
\&  ...
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \s-1RNA\s0.pm package gives access to almost all functions in the libRNA.a
library of the Vienna \s-1RNA PACKAGE.\s0 The Perl wrapper is generated using
\&\s-1SWIG\s0 http://www.swig.org/ with relatively little manual intervention.
For each C function in the library the perl package provides a function
of the same name and calling convention (with few exceptions). For
detailed information you should therefore also consult the documentation
of the library (info RNAlib).
.PP
Note that in general C arrays are wrapped into opaque objects that can
only be accessed via helper functions. \s-1SWIG\s0 provides a couple of general
purpose helper functions, see the section at the end of this file. C
structures are wrapped into Perl objects using \s-1SWIG\s0's shadow class
mechanism, resulting in a tied hash with keys named after the structure
members.
.PP
For the interrested reader we list for each scalar type of the
corepsonding C variable in brackets, and point out the header files
containing the C declaration.
.SS "Folding Routines"
.IX Subsection "Folding Routines"
Minimum free Energy Folding (from fold.h)
.IP "fold \s-1SEQUENCE\s0" 4
.IX Item "fold SEQUENCE"
.PD 0
.IP "fold \s-1SEQUENCE, CONSTRAINTS\s0" 4
.IX Item "fold SEQUENCE, CONSTRAINTS"
.PD
computes the minimum free energy structure of the string \s-1SEQUENCE\s0 and returns
the predicted structure and energy, e.g.
.Sp
.Vb 1
\&  ($structure, $mfe) = RNA::fold("UGUGUCGAUGUGCUAU");
.Ve
.Sp
If a second argument is supplied and
\&\f(CW$fold_constrained\fR==1 the \s-1CONSTRAINTS\s0 string is
used to specify constraints on the predicted structure.  The
characters '|', 'x', '<', '>' mark bases that are paired, unpaired,
paired upstream, or downstream, respectively; matching brackets \*(L"( )\*(R"
denote base pairs, dots '.' are used for unconstrained bases.
.Sp
In the two argument version the \s-1CONSTRAINTS\s0 string is modified and holds the
predicted structure upon return. This is done for backwards compatibility only,
and might change in future versions.
.IP "energy_of_struct \s-1SEQUENCE, STRUCTURE\s0" 4
.IX Item "energy_of_struct SEQUENCE, STRUCTURE"
returns the energy of \s-1SEQUENCE\s0 on \s-1STRUCTURE \s0(in kcal/mol). The string structure
must hold a valid secondary structure in bracket notation.
.IP "update_fold_params" 4
.IX Item "update_fold_params"
recalculate the pair matrix and energy parameters after a change in folding
parameters. In many cases (such as changes to
\&\f(CW$temperature\fR) the \fIfold()\fR routine will call
update_fold_params automatically when necessary.
.IP "free_arrays" 4
.IX Item "free_arrays"
frees memory allocated internally when calling fold.
.IP "cofold \s-1SEQUENCE\s0" 4
.IX Item "cofold SEQUENCE"
.PD 0
.IP "cofold \s-1SEQUENCE, CONSTRAINTS\s0" 4
.IX Item "cofold SEQUENCE, CONSTRAINTS"
.PD
works as fold, but \s-1SEQUENCE\s0 may be the concatenation of two RNAs in order
compute their hybridization structure. E.g.:
.Sp
.Vb 4
\&  $seq1  ="CGCAGGGAUACCCGCG";
\&  $seq2  ="GCGCCCAUAGGGACGC";
\&  $RNA::cut_point = length($seq1)+1;
\&  ($costruct, $comfe) = RNA::cofold($seq1 . $seq2);
.Ve
.IP "duplexfold \s-1SEQ1 SEQ2\s0" 4
.IX Item "duplexfold SEQ1 SEQ2"
compute the structure upon hybridization of \s-1SEQ1\s0 and \s-1SEQ2.\s0 In contrast to
cofold only intra-molecular pairs are allowed. Thus, the algorithm runs in
O(n1*n2) time where n1 and n2 are the lengths of the sequences. The result
is returned in a C struct containing the innermost base pair (i,j) the
structure and energy. E.g:
.Sp
.Vb 8
\&  $seq1 ="CGCAGGGAUACCCGCG";
\&  $seq2 ="GCGCCCAUAGGGACGC";
\&  $dup  = RNA::duplexfold($seq1, $seq2);
\&  print "Region ", $dup\->{i}+1\-length($seq1), " to ",
\&        $dup\->{i}, " of seq1 ",
\&        "pairs up with ", $dup\->{j}, " to ",
\&        $dup\->{j}+length($dup\->{structure})\-length($seq1)\-2,
\&        " of seq2\en";
.Ve
.PP
Partition function Folding (from part_func.h)
.IP "pf_fold \s-1SEQUENCE\s0" 4
.IX Item "pf_fold SEQUENCE"
.PD 0
.IP "pf_fold \s-1SEQUENCE, CONSTRAINTS\s0" 4
.IX Item "pf_fold SEQUENCE, CONSTRAINTS"
.PD
calculates the partition function over all possible secondary
structures and the matrix of pair probabilities for \s-1SEQUENCE\s0 and
returns a two element list consisting of a string summarizing possible
structures. See below on how to access the pair probability matrix. As
with fold the second argument can be used to specify folding
constraints. Constraints are implemented by excluding base pairings
that contradict the constraint, but without bonus
energies. Constraints of type '|' (paired base) are ignored.  In the
two argument version \s-1CONSTRAINTS\s0 is modified to contain the structure
string on return (obsolete feature, for backwards compatibility only)
.IP "get_pr I, J" 4
.IX Item "get_pr I, J"
After calling \f(CW\*(C`pf_fold\*(C'\fR the global C variable \f(CW\*(C`pr\*(C'\fR points to the
computed pair probabilities. Perl access to the C is facilitated by
the \f(CW\*(C`get_pr\*(C'\fR helper function that looks up and returns the
probability of the pair (I,J).
.IP "free_pf_arrays" 4
.IX Item "free_pf_arrays"
frees memory allocated for pf_fold
.IP "update_pf_params \s-1LENGTH\s0" 4
.IX Item "update_pf_params LENGTH"
recalculate energy parameters for pf_fold. In most cases (such as
simple changes to \f(CW$temperature\fR) \f(CW\*(C`pf_fold\*(C'\fR
will take appropriate action automatically.
.IP "pbacktrack \s-1SEQUENCE\s0" 4
.IX Item "pbacktrack SEQUENCE"
return a random structure chosen according to it's Boltzmann probability.
Use to produce samples representing the thermodynamic ensemble of
structures.
.Sp
.Vb 4
\&  RNA::pf_fold($sequence);
\&  for (1..1000) {
\&     push @sample, RNA::pbacktrack($sequence);
\&  }
.Ve
.IP "co_pf_fold \s-1SEQUENCE\s0" 4
.IX Item "co_pf_fold SEQUENCE"
.PD 0
.IP "co_pf_fold \s-1SEQUENCE, CONSTRAINTS\s0" 4
.IX Item "co_pf_fold SEQUENCE, CONSTRAINTS"
.PD
calculates the partition function over all possible secondary
structures and the matrix of pair probabilities for \s-1SEQUENCE.
SEQUENCE\s0 is a concatenation of two sequences (see cofold).
Returns a five element list consisting of a string summarizing possible
structures as first element. The second element is the Gibbs free energy of Sequence 1 (as computed also with pf_fold), the third element the Gibbs free energy of Sequence 2. The fourth element is the Gibbs free energy of all structures that have INTERmolecular base pairs, and finally the fifth element is the Gibbs free energy of the whole ensemble (dimers as well as monomers).
See above on how to access the pair probability matrix. As
with fold the second argument can be used to specify folding
constraints. Constraints are implemented by excluding base pairings
that contradict the constraint, but without bonus
energies. Constraints of type '|' (paired base) are ignored.  In the
two argument version \s-1CONSTRAINTS\s0 is modified to contain the structure
string on return (obsolete feature, for backwards compatibility only)
.IP "free_co_pf_arrays" 4
.IX Item "free_co_pf_arrays"
frees memory allocated for co_pf_fold
.IP "update_pf_co_params \s-1LENGTH\s0" 4
.IX Item "update_pf_co_params LENGTH"
recalculate energy parameters for co_pf_fold. In most cases (such as
simple changes to \f(CW$temperature\fR) \f(CW\*(C`co_pf_fold\*(C'\fR
will take appropriate action automatically.
.IP "get_concentrations FdAB, FdAA, FdBB, \s-1FA, FB, CONCA, CONCB\s0" 4
.IX Item "get_concentrations FdAB, FdAA, FdBB, FA, FB, CONCA, CONCB"
calculates equilibrium concentrations of the three dimers \s-1AB, AA,\s0 and \s-1BB,\s0 as well as the two monomers A and B out of the free energies of the duplexes (FdAB, FdAA, FdBB, these are the fourth elements returned by co_pf_fold), the monomers (\s-1FA, FB \s0(e.g. the second and third elements returned by co_pf_fold with sequences \s-1AB\s0) and the start concentrations of A and B. It returns as first element the concentration of \s-1AB\s0 dimer, than \s-1AA\s0 and \s-1BB\s0 dimer, as fourth element the A monomer concentration, and as fifth and last element the B monomer concentration.
So, to compute concentrations, you first have to run 3 co_pf_folds (with sequences \s-1AB, AA\s0 and \s-1BB\s0).
.PP
Suboptimal Folding (from subopt.h)
.IP "subopt \s-1SEQUENCE, CONSTRAINTS, DELTA\s0" 4
.IX Item "subopt SEQUENCE, CONSTRAINTS, DELTA"
.PD 0
.IP "subopt \s-1SEQUENCE, CONSTRAINTS, DELTA, FILEHANDLE\s0" 4
.IX Item "subopt SEQUENCE, CONSTRAINTS, DELTA, FILEHANDLE"
.PD
compute all structures of \s-1SEQUENCE\s0 within DELTA*0.01 kcal/mol of the
optimum. If specified, results are written to \s-1FILEHANDLE\s0 and nothing
is returned. Else, the C function returnes a list of C structs of type
\&\s-1SOLUTION.\s0 The list is wrapped by \s-1SWIG\s0 as a perl object that can be
accesses as follows:
.Sp
.Vb 5
\&  $solution = subopt($seq, undef, 500);
\&  for (0..$solution\->size()\-1) {
\&     printf "%s %6.2f\en",  $solution\->get($_)\->{structure},
\&                           $solution\->get($_)\->{energy};
\&  }
.Ve
.PP
Alignment Folding (from alifold.h)
.IP "alifold \s-1REF\s0" 4
.IX Item "alifold REF"
.PD 0
.IP "fold \s-1REF, CONSTRAINTS\s0" 4
.IX Item "fold REF, CONSTRAINTS"
.PD
similar to \fIfold()\fR but compute the consensus structure for a set of aligned
sequences. E.g.:
.Sp
.Vb 4
\&  @align = ("GCCAUCCGAGGGAAAGGUU",
\&            "GAUCGACAGCGUCU\-AUCG",
\&            "CCGUCUUUAUGAGUCCGGC");
\&  ($consens_struct, $consens_en) = RNA::alifold(\e@align);
.Ve
.IP "consensus \s-1REF\s0 =item consens_mis \s-1REF\s0" 4
.IX Item "consensus REF =item consens_mis REF"
compute a simple consensus sequence or \*(L"most informative sequence\*(R" form an
alignment. The simple consensus returns the most frequent character for
each column, the \s-1MIS\s0 uses the \s-1IUPAC\s0 symbol that contains all characters
that are overrepresented in the column.
.Sp
.Vb 1
\&  $mis = consensus_mis(\e@align);
.Ve
.PP
Inverse Folding (from inverse.h)
.IP "inverse_fold \s-1START, TARGET\s0" 4
.IX Item "inverse_fold START, TARGET"
find a sequence that folds into structure \s-1TARGET,\s0 by optimizing the
sequence until its mfe structure (as returned by fold) is
\&\s-1TARGET.\s0 Startpoint of the optimization is the sequence \s-1START.\s0 Returns
a list containing the sequence found and the final value of the cost
function, i.e. 0 if the search was successful. A random start sequence
can be generated using random_string.
.IP "inverse_pf_fold \s-1START, TARGET\s0" 4
.IX Item "inverse_pf_fold START, TARGET"
optimizes a sequence (beginning with \s-1START\s0) by maximising the
frequency of the structure \s-1TARGET\s0 in the thermodynamic ensemble
of structures. Returns a list containing the optimized sequence and
the final value of the cost function. The cost function is given by
\&\f(CW\*(C`energy_of_struct(seq, TARGET) \- pf_fold(seq)\*(C'\fR, i.e.\f(CW\*(C`\-RT*log(p(TARGET))\*(C'\fR
.ie n .IP "$final_cost [float]" 4
.el .IP "\f(CW$final_cost\fR [float]" 4
.IX Item "$final_cost [float]"
holds the value of the cost function where the optimization in
\&\f(CW\*(C`inverse_pf_fold\*(C'\fR should stop. For values <=0 the optimization will
only terminate at a local optimimum (which might take very long to reach).
.ie n .IP "$symbolset [char *]" 4
.el .IP "\f(CW$symbolset\fR [char *]" 4
.IX Item "$symbolset [char *]"
the string symbolset holds the allowed characters to be used by
\&\f(CW\*(C`inverse_fold\*(C'\fR and \f(CW\*(C`inverse_pf_fold\*(C'\fR, the default alphabet is \*(L"\s-1AUGC\*(R"\s0
.ie n .IP "$give_up [int]" 4
.el .IP "\f(CW$give_up\fR [int]" 4
.IX Item "$give_up [int]"
If non-zero stop optimization when its clear that no exact solution
can be found. Else continue and eventually return an approximate
solution. Default 0.
.PP
Cofolding of two \s-1RNA\s0 molecules (from cofold.h)
.PP
Global Variables to Modify Folding (from fold_vars.h)
.ie n .IP "$noGU [int]" 4
.el .IP "\f(CW$noGU\fR [int]" 4
.IX Item "$noGU [int]"
Do not allow \s-1GU\s0 pairs to form, default 0.
.ie n .IP "$no_closingGU [int]" 4
.el .IP "\f(CW$no_closingGU\fR [int]" 4
.IX Item "$no_closingGU [int]"
allow \s-1GU\s0 only inside stacks, default 0.
.ie n .IP "$tetra_loop [int]" 4
.el .IP "\f(CW$tetra_loop\fR [int]" 4
.IX Item "$tetra_loop [int]"
Fold with specially stable 4\-loops, default 1.
.ie n .IP "$energy_set [int]" 4
.el .IP "\f(CW$energy_set\fR [int]" 4
.IX Item "$energy_set [int]"
0 = \s-1BP\s0; 1=any mit \s-1GC\s0; 2=any mit AU-parameter, default 0.
.ie n .IP "$dangles [int]" 4
.el .IP "\f(CW$dangles\fR [int]" 4
.IX Item "$dangles [int]"
How to compute dangling ends. 0: no dangling end energies, 1: \*(L"normal\*(R"
dangling ends (default), 2: simplified dangling ends, 3: \*(L"normal\*(R" +
co-axial stacking. Note that pf_fold treats cases 1 and 3
as 2. The same holds for the main computation in subopt,
however subopt will re-evalute energies using
energy_of_struct for cases 1 and 3. See the more
detailed discussion in RNAlib.texinfo.
.ie n .IP "$nonstandards [char *]" 4
.el .IP "\f(CW$nonstandards\fR [char *]" 4
.IX Item "$nonstandards [char *]"
contains allowed non standard bases, default empty string ""
.ie n .IP "$temperature [double]" 4
.el .IP "\f(CW$temperature\fR [double]" 4
.IX Item "$temperature [double]"
temperature in degrees Celsius for rescaling parameters, default 37C.
.ie n .IP "$logML [int]" 4
.el .IP "\f(CW$logML\fR [int]" 4
.IX Item "$logML [int]"
use logarithmic multiloop energy function in
energy_of_struct, default 0.
.ie n .IP "$noLonelyPairs [int]" 4
.el .IP "\f(CW$noLonelyPairs\fR [int]" 4
.IX Item "$noLonelyPairs [int]"
consider only structures without isolated base pairs (helices of length 1).
For pf_fold only eliminates pairs
that can \fBonly\fR occur as isolated pairs. Default 0.
.ie n .IP "$base_pair [struct bond *]" 4
.el .IP "\f(CW$base_pair\fR [struct bond *]" 4
.IX Item "$base_pair [struct bond *]"
list of base pairs from last call to fold. Better use
the structure string returned by  fold.
.ie n .IP "$pf_scale [double]" 4
.el .IP "\f(CW$pf_scale\fR [double]" 4
.IX Item "$pf_scale [double]"
scaling factor used by pf_fold to avoid overflows. Should
be set to exp(\-F/(RT*length)) where F is a guess for the ensmble free
energy (e.g. use the mfe).
.ie n .IP "$fold_constrained [int]" 4
.el .IP "\f(CW$fold_constrained\fR [int]" 4
.IX Item "$fold_constrained [int]"
apply constraints in the folding algorithms, default 0.
.ie n .IP "$do_backtrack [int]" 4
.el .IP "\f(CW$do_backtrack\fR [int]" 4
.IX Item "$do_backtrack [int]"
If 0 do not compute the pair probabilities in pf_fold
(only the partition function). Default 1.
.ie n .IP "$backtrack_type [char]" 4
.el .IP "\f(CW$backtrack_type\fR [char]" 4
.IX Item "$backtrack_type [char]"
usually 'F'; 'C' require (1,N) to be bonded; 'M' backtrack as if the
sequence was part of a multi loop. Used by inverse_fold
.ie n .IP "$pr [double *]" 4
.el .IP "\f(CW$pr\fR [double *]" 4
.IX Item "$pr [double *]"
the base pairing prob. matrix computed by pf_fold.
.ie n .IP "$iindx [int *]" 4
.el .IP "\f(CW$iindx\fR [int *]" 4
.IX Item "$iindx [int *]"
Array of indices for moving withing the \f(CW\*(C`pr\*(C'\fR array. Better use
get_pr.
.SS "Parsing and Comparing Structures"
.IX Subsection "Parsing and Comparing Structures"
from RNAstruct.h: these functions convert between strings
representating secondary structures with various levels of coarse
graining. See the documentation of the C library for details
.IP "b2HIT \s-1STRUCTURE\s0" 4
.IX Item "b2HIT STRUCTURE"
Full \-> \s-1HIT\s0 [incl. root]
.IP "b2C \s-1STRUCTURE\s0" 4
.IX Item "b2C STRUCTURE"
Full \-> Coarse [incl. root]
.IP "b2Shapiro \s-1STRUCTURE\s0" 4
.IX Item "b2Shapiro STRUCTURE"
Full \-> weighted Shapiro [i.r.]
.IP "add_root \s-1STRUCTURE\s0" 4
.IX Item "add_root STRUCTURE"
{Tree} \-> ({Tree}R)
.IP "expand_Shapiro \s-1COARSE\s0" 4
.IX Item "expand_Shapiro COARSE"
add S for stacks to coarse struct
.IP "expand_Full \s-1STRUCTURE\s0" 4
.IX Item "expand_Full STRUCTURE"
Full \-> FFull
.IP "unexpand_Full \s-1FSTRUCTURE\s0" 4
.IX Item "unexpand_Full FSTRUCTURE"
FFull \-> Full
.IP "unweight \s-1WCOARSE\s0" 4
.IX Item "unweight WCOARSE"
remove weights from coarse struct
.IP "unexpand_aligned_F \s-1ALIGN\s0" 4
.IX Item "unexpand_aligned_F ALIGN"
.PD 0
.IP "parse_structure \s-1STRUCTURE\s0" 4
.IX Item "parse_structure STRUCTURE"
.PD
computes structure statistics, and fills the following global variables:
.Sp
\&\f(CW$loops\fR    [int] number of loops (and stacks)
\&\f(CW$unpaired\fR [int] number of unpaired positions
\&\f(CW$pairs\fR    [int] number of paired positions
\&\f(CW$loop_size\fR[int *]  holds all loop sizes
\&\f(CW$loop_degree\fR[int *] holds all loop degrees
\&\f(CW$helix_size\fR[int *] holds all helix lengths
.PP
from treedist.h: routines for computing tree-edit distances between structures
.IP "make_tree \s-1XSTRUCT\s0" 4
.IX Item "make_tree XSTRUCT"
convert a structure string as produced by the expand_... functions to a
Tree, useable as input to tree_edit_distance.
.IP "tree_edit_distance T1, T2" 4
.IX Item "tree_edit_distance T1, T2"
compare to structures using tree editing. \f(CW\*(C`T1\*(C'\fR, \f(CW\*(C`T2\*(C'\fR must have been
created using \f(CW\*(C`tree_edit_distance\*(C'\fR
.IP "print_tree T" 4
.IX Item "print_tree T"
mainly for debugging
.IP "free_tree T" 4
.IX Item "free_tree T"
free space allocated by make_tree
.PP
from stringdist.h routines to compute structure distances via string-editing
.IP "Make_swString \s-1STRUCTURE\s0" 4
.IX Item "Make_swString STRUCTURE"
[ returns swString * ]
make input for string_edit_distance
.IP "string_edit_distance S1, S2" 4
.IX Item "string_edit_distance S1, S2"
[ returns float  ]
compare to structures using string alignment. \f(CW\*(C`S1\*(C'\fR, \f(CW\*(C`S2\*(C'\fR should be
created using \f(CW\*(C`Make_swString\*(C'\fR
.PP
from profiledist
.IP "Make_bp_profile \s-1LENGTH\s0" 4
.IX Item "Make_bp_profile LENGTH"
[ returns (float *) ]
condense pair probability matrix \f(CW\*(C`pr\*(C'\fR into a vector containing
probabilities for unpaired, upstream paired and downstream paired.
This resulting probability profile is used as input for
profile_edit_distance
.IP "profile_edit_distance T1, T2" 4
.IX Item "profile_edit_distance T1, T2"
[ returns float ]
align two probability profiles produced by \f(CW\*(C`Make_bp_profile\*(C'\fR
.IP "print_bppm T" 4
.IX Item "print_bppm T"
[ returns void ]
print string representation of probability profile
.IP "free_profile T" 4
.IX Item "free_profile T"
[ returns void ]
free space allocated in Make_bp_profile
.PP
Global variables for computing structure distances
.ie n .IP "$edit_backtrack [int]" 4
.el .IP "\f(CW$edit_backtrack\fR [int]" 4
.IX Item "$edit_backtrack [int]"
set to 1 if you want backtracking
.ie n .IP "$aligned_line [(char *)[2]]" 4
.el .IP "\f(CW$aligned_line\fR [(char *)[2]]" 4
.IX Item "$aligned_line [(char *)[2]]"
containes alignmed structures after computing structure distance with
\&\f(CW\*(C`edit_backtrack==1\*(C'\fR
.ie n .IP "$cost_matrix [int]" 4
.el .IP "\f(CW$cost_matrix\fR [int]" 4
.IX Item "$cost_matrix [int]"
0 usual costs (default), 1 Shapiro's costs
.SS "Utilities (from utils.h)"
.IX Subsection "Utilities (from utils.h)"
.IP "space \s-1SIZE\s0" 4
.IX Item "space SIZE"
allocate memory from C. Usually not needed in Perl
.IP "nrerror \s-1MESSGAE\s0" 4
.IX Item "nrerror MESSGAE"
die with error message. Better use Perl's \f(CW\*(C`die\*(C'\fR
.ie n .IP "$xsubi [unsigned short[3]]" 4
.el .IP "\f(CW$xsubi\fR [unsigned short[3]]" 4
.IX Item "$xsubi [unsigned short[3]]"
libRNA uses the rand48 48bit random number generator if available, the
current random  number is always stored in \f(CW$xsubi\fR.
.IP "init_rand" 4
.IX Item "init_rand"
initialize the \f(CW$xsubi\fR random number from current time
.IP "urn" 4
.IX Item "urn"
returns a random number between 0 and 1 using the random number
generator from the \s-1RNA\s0 library.
.IP "int_urn \s-1FROM, TO\s0" 4
.IX Item "int_urn FROM, TO"
returns random integer in the range [\s-1FROM..TO\s0]
.IP "time_stamp" 4
.IX Item "time_stamp"
current date in a string. In perl you might as well use \f(CW\*(C`locatime\*(C'\fR
.IP "random_string \s-1LENGTH, SYMBOLS\s0" 4
.IX Item "random_string LENGTH, SYMBOLS"
returns a string of length \s-1LENGTH\s0 using characters from the string
\&\s-1SYMBOLS\s0
.IP "hamming S1, S2" 4
.IX Item "hamming S1, S2"
calculate hamming distance of the strings \f(CW\*(C`S1\*(C'\fR and \f(CW\*(C`S2\*(C'\fR.
.IP "pack_structure \s-1STRUCTURE\s0" 4
.IX Item "pack_structure STRUCTURE"
pack secondary structure, using a 5:1 compression via 3
encoding. Returns the packed string.
.IP "unpack_structure \s-1PACKED\s0" 4
.IX Item "unpack_structure PACKED"
unpacks a secondary structure packed with pack_structure
.IP "make_pair_table \s-1STRUCTURE\s0" 4
.IX Item "make_pair_table STRUCTURE"
returns a pair table as a newly allocated (short *) C array, such
that: table[i]=j if (i.j) pair or 0 if i is unpaired, table[0]
contains the length of the structure.
.IP "bp_distance \s-1STRUCTURE1, STRUCTURE2\s0" 4
.IX Item "bp_distance STRUCTURE1, STRUCTURE2"
returns the base pair distance of the two \s-1STRUCTURES.\s0 dist = {number
of base pairs in one structure but not in the other} same as edit
distance with open-pair close-pair as move-set
.PP
from PS_plot.h
.IP "PS_rna_plot \s-1SEQUENCE, STRUCTURE, FILENAME\s0" 4
.IX Item "PS_rna_plot SEQUENCE, STRUCTURE, FILENAME"
write PostScript drawing of structure to \s-1FILENAME.\s0 Returns 1 on
sucess, 0 else.
.IP "PS_rna_plot_a \s-1SEQUENCE, STRUCTURE, FILENAME, PRE, POST\s0" 4
.IX Item "PS_rna_plot_a SEQUENCE, STRUCTURE, FILENAME, PRE, POST"
write PostScript drawing of structure to \s-1FILENAME.\s0 The strings \s-1PRE\s0 and
\&\s-1POST\s0 contain PostScript code that is included verbatim in the plot just
before (after) the data.  Returns 1 on sucess, 0 else.
.IP "gmlRNA \s-1SEQUENCE, STRUCTURE, FILENAME, OPTION\s0" 4
.IX Item "gmlRNA SEQUENCE, STRUCTURE, FILENAME, OPTION"
write structure drawing in gml (Graph Meta Language) to
\&\s-1FILENAME. OPTION\s0 should be a single character. If uppercase the gml
output will include the \s-1SEQUENCE\s0 as node labels. \s-1IF OPTION\s0 equal 'x'
or 'X' write graph with coordinates (else only connectivity
information). Returns 1 on sucess, 0 else.
.IP "ssv_rna_plot \s-1SEQUENCE, STRUCTURE, SSFILE\s0" 4
.IX Item "ssv_rna_plot SEQUENCE, STRUCTURE, SSFILE"
write structure drfawing as coord file for SStructView Returns 1 on
sucess, 0 else.
.IP "xrna_plot \s-1SEQUENCE, STRUCTURE, SSFILE\s0" 4
.IX Item "xrna_plot SEQUENCE, STRUCTURE, SSFILE"
write structure drawing as \*(L".ss\*(R" file for further editing in \s-1XRNA.\s0
Returns 1 on sucess, 0 else.
.IP "PS_dot_plot \s-1SEQUENCE, FILENAME\s0" 4
.IX Item "PS_dot_plot SEQUENCE, FILENAME"
write a PostScript dot plot of the pair probability matix to
\&\s-1FILENAME.\s0 Returns 1 on sucess, 0 else.
.ie n .IP "$rna_plot_type [int]" 4
.el .IP "\f(CW$rna_plot_type\fR [int]" 4
.IX Item "$rna_plot_type [int]"
Select layout algorithm for structure drawings. Currently available
0= simple coordinates, 1= naview, default 1.
.PP
from read_epars.c
.IP "read_parameter_file \s-1FILENAME\s0" 4
.IX Item "read_parameter_file FILENAME"
read energy parameters from \s-1FILENAME\s0
.IP "write_parameter_file \s-1FILENAME\s0" 4
.IX Item "write_parameter_file FILENAME"
write energy parameters to \s-1FILENAME\s0
.SS "\s-1SWIG\s0 helper functions"
.IX Subsection "SWIG helper functions"
The package includes generic helper functions to access C arrays
of type \f(CW\*(C`int\*(C'\fR, \f(CW\*(C`float\*(C'\fR and \f(CW\*(C`double\*(C'\fR, such as:
.IP "intP_getitem \s-1POINTER, INDEX\s0" 4
.IX Item "intP_getitem POINTER, INDEX"
return the element \s-1INDEX\s0 from the array
.IP "intP_setitem \s-1POINTER, INDEX, VALUE\s0" 4
.IX Item "intP_setitem POINTER, INDEX, VALUE"
set element \s-1INDEX\s0 to \s-1VALUE\s0
.IP "new_intP \s-1NELEM\s0" 4
.IX Item "new_intP NELEM"
allocate a new C array of integers with \s-1NELEM\s0 elements and return the pointer
.IP "delete_intP \s-1POINTER\s0" 4
.IX Item "delete_intP POINTER"
deletes the C array by calling \fIfree()\fR
.PP
substituting \f(CW\*(C`intP\*(C'\fR with \f(CW\*(C`floatP\*(C'\fR, \f(CW\*(C`doubleP\*(C'\fR, \f(CW\*(C`ushortP\*(C'\fR,
\&\f(CW\*(C`shortP\*(C'\fR, gives the corresponding functions for arrays of float or
double, unsigned short, and short. You need to know the correct C
type however, and the functions work only for arrays of simple types.
Note, that the shortP... functions were used for unsigned short in previous
versions, while starting with v1.8.3 it can only access signed short arrays.
.PP
On the lowest level the \f(CW\*(C`cdata\*(C'\fR function gives direct access to any data
in the form of a Perl string.
.IP "cdata \s-1POINTER, SIZE\s0" 4
.IX Item "cdata POINTER, SIZE"
copies \s-1SIZE\s0 bytes at \s-1POINTER\s0 to a Perl string (with binary data)
.IP "memmove \s-1POINTER, STRING\s0" 4
.IX Item "memmove POINTER, STRING"
copies the (binary) string \s-1STRING\s0 to the memory location pointed to by
\&\s-1POINTER.\s0
Note: memmove is broken in current swig versions (e.g. 1.3.31)
.PP
In combination with Perl's \f(CW\*(C`unpack\*(C'\fR this provides a generic way to convert
C data structures to Perl. E.g.
.PP
.Vb 2
\&  RNA::parse_structure($structure);  # fills the $RNA::loop_degree array
\&  @ldegrees = unpack "I*", RNA::cdata($RNA::loop_degree, ($RNA::loops+1)*4);
.Ve
.PP
Warning: using these functions with wrong arguments will corrupt your
memory and lead to a segmentation fault.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ivo L. Hofacker <ivo@tbi.univie.ac.at>
